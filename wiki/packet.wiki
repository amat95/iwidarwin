#summary this is information of ieee80211 packet , skb(linux's sk_buff) and mbuf
#labels packet,ieee80211,sk_buff,mbuf

= 802.11 Data Frame =
from ieee80211_tx.c comments

{{{

      ,-------------------------------------------------------------------.
Bytes |  2   |  2   |    6    |    6    |    6    |  2   | 0..2312 |   4  |
      |------|------|---------|---------|---------|------|---------|------|
Desc. | ctrl | dura |  DA/RA  |   TA    |    SA   | Sequ |  Frame  |  fcs |
      |      | tion | (BSSID) |         |         | ence |  data   |      |
      `--------------------------------------------------|         |------'
Total: 28 non-data bytes                                 `----.----'
                                                              |
       .- 'Frame data' expands, if WEP enabled, to <----------'
       |
       V
      ,-----------------------.
Bytes |  4  |   0-2296  |  4  |
      |-----|-----------|-----|
Desc. | IV  | Encrypted | ICV |
      |     | Packet    |     |
      `-----|           |-----'
            `-----.-----'
                  |
       .- 'Encrypted Packet' expands to
       |
       V
      ,---------------------------------------------------.
Bytes |  1   |  1   |    1    |    3     |  2   |  0-2304 |
      |------|------|---------|----------|------|---------|
Desc. | SNAP | SNAP | Control |Eth Tunnel| Type | IP      |
      | DSAP | SSAP |         |          |      | Packet  |
      | 0xAA | 0xAA |0x03 (UI)|0x00-00-F8|      |         |
      `----------------------------------------------------
Total: 8 non-data bytes
}}}

== 802.3 Ethernet Data Frame ==
{{{
      ,-----------------------------------------.
Bytes |   6   |   6   |  2   |  Variable |   4  |
      |-------|-------|------|-----------|------|
Desc. | Dest. | Source| Type | IP Packet |  fcs |
      |  MAC  |  MAC  |      |           |      |
      `-----------------------------------------'
Total: 18 non-data bytes

}}}

In the event that fragmentation is required, the incoming payload is split into
N parts of size ieee->fts.  The first fragment contains the SNAP header and the
remaining packets are just data.

If encryption is enabled, each fragment payload size is reduced by enough space
to add the prefix and postfix (IV and ICV totalling 8 bytes in the case of WEP)
So if you have 1500 bytes of payload with ieee->fts set to 500 without
encryption it will take 3 frames.  With WEP it will take 4 frames as the
payload of each frame is reduced to 492 bytes.

= sk_buff =


== struct ==
{{{

  ,- skb->data
 |
 |    ETHERNET HEADER        ,-<-- PAYLOAD
 |                           |     14 bytes from skb->data
 |  2 bytes for Type --> ,T. |     (sizeof ethhdr)
 |                       | | |
 |,-Dest.--. ,--Src.---. | | |
 |  6 bytes| | 6 bytes | | | |
 v         | |         | | | |
 0         | v       1 | v | v           2
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
     ^     | ^         | ^ |
     |     | |         | | |
     |     | |         | `T' <---- 2 bytes for Type
     |     | |         |
     |     | '---SNAP--' <-------- 6 bytes for SNAP
     |     |
     `-IV--' <-------------------- 4 bytes for IV (WEP)

      SNAP HEADER
}}}
= mbuf =
{{{
struct mbuf {
        struct  m_hdr m_hdr;
        union {
                struct {
                        struct  pkthdr MH_pkthdr;       /* M_PKTHDR set */
                        union {
                                struct  m_ext MH_ext;   /* M_EXT set */
                                char    MH_databuf[MHLEN];
                        } MH_dat;
                } MH;
                char    M_databuf[MLEN];                /* !M_PKTHDR, !M_EXT */
        } M_dat;
};

struct m_ext {
        caddr_t ext_buf;                /* start of buffer */
        void    (*ext_free)(caddr_t , u_int, caddr_t);  /* free routine if not the usual */        u_int   ext_size;               /* size of buffer, for ext_free */
        caddr_t ext_arg;                /* additional ext_free argument */
        struct  ext_refsq {             /* references held */
                struct ext_refsq *forward, *backward;
        } ext_refs;
};
/* header at beginning of each mbuf: */
struct m_hdr {
        struct  mbuf *mh_next;          /* next buffer in chain */
        struct  mbuf *mh_nextpkt;       /* next chain in queue/record */
        long    mh_len;                 /* amount of data in this mbuf */
        caddr_t mh_data;                /* location of data */
        short   mh_type;                /* type of data in this mbuf */
        short   mh_flags;               /* flags; see below */
};
struct m_tag {
        SLIST_ENTRY(m_tag)      m_tag_link;     /* List of packet tags */
        u_int16_t                       m_tag_type;     /* Module specific type */
        u_int16_t                       m_tag_len;      /* Length of data */
        u_int32_t                       m_tag_id;       /* Module ID */
};
struct  pkthdr {
        int     len;                    /* total packet length */
        struct  ifnet *rcvif;           /* rcv interface */

        /* variables for ip and tcp reassembly */
        void    *header;                /* pointer to packet header */
        /* variables for hardware checksum */
#ifdef KERNEL_PRIVATE
        /* Note: csum_flags is used for hardware checksum and VLAN */
#endif KERNEL_PRIVATE
        int     csum_flags;             /* flags regarding checksum */       
        int     csum_data;              /* data field used by csum routines */
        struct mbuf *aux;               /* extra data buffer; ipsec/others */
#ifdef KERNEL_PRIVATE
        u_short vlan_tag;               /* VLAN tag, host byte order */
        u_short socket_id;              /* socket id */
#else KERNEL_PRIVATE
        u_int   reserved1;              /* for future use */
#endif KERNEL_PRIVATE
        SLIST_HEAD(packet_tags, m_tag) tags; /* list of packet tags */
};
}}}
= function =
from bsd/sys/kpi_mbuf.h 
   * mbuf_data
   * mbuf_datastart 
   * mbuf_setdata
   * mbuf_align_32
   * mbuf_data_to_physical
   * mbuf_get
   * mbuf_getcluster
   * mbuf_mclget
   * mbuf_mclget
   * etc